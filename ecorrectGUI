#!/usr/bin/env python3

import tkinter as tk
import tkinter.filedialog as tkfd
import tkinter.messagebox as tkmb
import tkinter.ttk as ttk
import tkinter.font as tkf
import sys, os, shutil, re

# load ecorrect:
import importlib as il
import importlib.util as ilu
s_ecorrect = ilu.spec_from_loader("ecorrect", il.machinery.SourceFileLoader("ecorrect", "./ecorrect"))
ecorrect   = ilu.module_from_spec(s_ecorrect)
# Execute the ecorrect Load
s_ecorrect.loader.exec_module(ecorrect)


# Collection of Regex-filter:

## Initiale Punkt-Zeile
r_init_line = r"^> Gesamtpunktzahl: (\d+)\/(\d+)\s\(\w+\)$"
## Beginn einer Aufgabe: 
r_task_start = r"^(?P<title>.*)\s*[^(0-9](?P<got_pts>\d+)\/(?P<max_pts>\d+)\sPunkte?$"
## Beginn einer Unteraufgabe:
r_subtask_start = r"^\s-\s(\w+)\)\s(?P<title>.*)\((?P<got_pts>\d+)\/(?P<max_pts>\d+)\)$"


def getNum(a):
    a = str(a) # ensure string to not cut off floats 
    try: 
        f = float(a)
        if f % 1 == 0:
            i = int(f)
            return i
        else:
            return f
    except ValueError:
        return 0.0

def getGroupTag(g):
    return "korrektur-" + g.replace("Group: ","").replace(" ","_") + ".txt"

class TextScrollCombo(tk.Frame):
    """ somewhat adapted from https://stackoverflow.com/questions/13832720/how-to-attach-a-scrollbar-to-a-text-widget"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.grid_propagate(False)
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.fnt = tkf.Font(size=12)
        self.txt = tk.Text(self,relief='flat',undo=True, wrap='word',borderwidth=0, font=self.fnt)
        self.txt.grid(row=0, column=0, sticky="nsew")

        # scrollb = ttk.Scrollbar(self, command=self.txt.yview)
        # scrollb.grid(row=0, column=1, sticky='nsew')
        # self.txt['yscrollcommand'] = scrollb.set

class ScrolledWindow(tk.Frame):
    """
    1. Master widget gets scrollbars and a canvas. Scrollbars are connected 
    to canvas scrollregion.

    2. self.scrollwindow is created and inserted into canvas

    Usage Guideline:
    Assign any widgets as children of <ScrolledWindow instance>.scrollwindow
    to get them inserted into canvas

    __init__(self, parent, canv_w = 400, canv_h = 400, *args, **kwargs)
    docstring:
    Parent = master of scrolled window
    canv_w - width of canvas
    canv_h - height of canvas

    Adapted from: https://stackoverflow.com/questions/16188420/tkinter-scrollbar-for-frame
    """


    def __init__(self, parent, canv_w = 400, canv_h = 400, *args, **kwargs):
        """Parent = master of scrolled window
        canv_w - width of canvas
        canv_h - height of canvas

       """
        super().__init__(parent, *args, **kwargs)

        self.parent = parent

        # creating a scrollbars
        # self.xscrlbr = ttk.Scrollbar(self.parent, orient = 'horizontal')
        # self.xscrlbr.grid(column = 0, row = 1, sticky = 'ew', columnspan = 2)         
        self.yscrlbr = ttk.Scrollbar(self.parent)
        self.yscrlbr.grid(column = 1, row = 0, sticky = 'ns')         
        # creating a canvas
        self.canv = tk.Canvas(self.parent)
        self.canv.config(relief = 'flat',
                         width = 10,
                         heigh = 10, bd = 2)
        # placing a canvas into frame
        self.canv.grid(column = 0, row = 0, sticky = 'nsew')
        # accociating scrollbar comands to canvas scroling
        # self.xscrlbr.config(command = self.canv.xview)
        self.yscrlbr.config(command = self.canv.yview)

        # creating a frame to inserto to canvas
        self.scrollwindow = tk.Frame(self.parent)

        self.canv_frame = self.canv.create_window(0, 0, window = self.scrollwindow, anchor = 'nw')

        self.canv.config(# xscrollcommand = self.xscrlbr.set,
                         yscrollcommand = self.yscrlbr.set,
                         scrollregion = (0, 0, 100, 100))

        self.yscrlbr.lift(self.scrollwindow)        
        # self.xscrlbr.lift(self.scrollwindow)
        self.scrollwindow.bind('<Configure>', self._configure_window)  
        self.scrollwindow.bind('<Enter>', self._bound_to_mousewheel)
        self.scrollwindow.bind('<Leave>', self._unbound_to_mousewheel)
        self.canv.bind('<Configure>', self._configure_width)  

        tk.Grid.columnconfigure(self.scrollwindow, 0, weight=1)

        return

    def _bound_to_mousewheel(self, event):
        self.canv.bind_all("<MouseWheel>", self._on_mousewheel)
        self.canv.bind_all("<Button-4>", self._on_mousewheel)
        self.canv.bind_all("<Button-5>", self._on_mousewheel)

    def _unbound_to_mousewheel(self, event):
        self.canv.unbind_all("<MouseWheel>") 
        self.canv.unbind_all("<Button-4>")
        self.canv.unbind_all("<Button-5>")

    def _on_mousewheel(self, event):
        if event.num == 5: # downwards linux
            self.canv.yview_scroll(int(240/120), "units")  
        elif event.num == 4: # upwards linux
            self.canv.yview_scroll(int(-240/120), "units")  
        else:
            self.canv.yview_scroll(int(-1*(event.delta/120)), "units")  

    def _configure_window(self, event):
        self.canv.config(scrollregion=self.canv.bbox("all"))
        if self.scrollwindow.winfo_reqwidth() != self.canv.winfo_width():
            # update the canvas's width to fit the inner frame
            self.canv.config(width = self.scrollwindow.winfo_reqwidth())
        if self.scrollwindow.winfo_reqheight() != self.canv.winfo_height():
            # update the canvas's width to fit the inner frame
            self.canv.config(height = self.scrollwindow.winfo_reqheight())

    def _configure_width(self, event):
        self.canv.itemconfig(self.canv_frame, width = event.width)

class StdoutRedirector(object):
    """ adaptet from: https://stackoverflow.com/questions/18517084/how-to-redirect-stdout-to-a-tkinter-text-widget"""
    def __init__(self, text_widget, old_out):
        self.text_space = text_widget
        self.old = old_out

    def write(self,string):
        # mirror output
        self.old.write(string)
        self.text_space.config(state='normal')
        self.text_space.insert('end', string)
        self.text_space.see('end')
        self.text_space.config(state='disabled')

class SubTaskBlock():
    """ Sub Task Block"""
    def __init__(self, master, master_points, number : int, name : str, points : int):
        self.master = master
        self.sub_task_number = number
        self.sub_task_name = name
        self.sub_task_old_points = 0
        self.sub_task_points = points
        self.master_points = master_points

        tmp = tk.Label(self.master, text=self.sub_task_name, width=60, justify='left', anchor='w')
        tmp.grid(column=0, row=self.sub_task_number, sticky='nsew', padx=4)
        self.points = tk.StringVar()
        self.points.set(0)
        lb_points = tk.Entry(self.master,width=4,textvariable=self.points,justify='right')
        lb_points.grid(column=2,row=self.sub_task_number, sticky='nsew')

        self.tcb = self.points.trace_add('write', self.points_validation)

        self.lb_tp = tk.Label(self.master, text="/" + str(self.sub_task_points))
        self.lb_tp.grid(column=3,row=self.sub_task_number, sticky='nsew', padx=4)

        self.correction_tsc = TextScrollCombo(self.master, height=100)
        self.correction_tsc.grid(row=self.sub_task_number+1, column=0, columnspan=4, padx=2, pady=7, sticky='nsew')

    def Xset(self, a):
        """set points without trace"""
        self.points.trace_remove('write', self.tcb)
        self.points.set(a)
        self.tcb = self.points.trace_add('write', self.points_validation)

    def points_validation(self, a, b, c):
        val = getNum(self.points.get())
        if val > self.sub_task_points:
            print("Für", "die Unteraufgabe", str(self.sub_task_number), "wurden zu viele Punkte angerechnet. Setze auf Maximum.")
            self.points.set(self.sub_task_points)
        elif val < 0:
            print("Für", "die Unteraufgabe", str(self.sub_task_number), "wurden negative Punkte angerechnet. Setze auf 0.")
            self.points.set("0")

        delta_points = getNum(self.master_points.get()) - self.sub_task_old_points
        self.master_points.set(getNum(delta_points + getNum(self.points.get())))
        self.sub_task_old_points = getNum(self.points.get())


class TaskBlock():
    """ Task Block for correction"""
    def __init__(self, master, number : int, name : str, points : int, subtasks = None):
        self.master = master
        self.task_number = number
        self.task_name = name
        self.task_points = points
        self.subtasks = []

        lf_fs = tkf.Font(size=16)

        self.mf = tk.LabelFrame(master, text = "Aufgabe " + str(self.task_number), font=lf_fs)
        tk.Grid.columnconfigure(self.mf, 1, weight=1)
        tk.Grid.rowconfigure(self.mf, 1, weight=1)

        tmp = tk.Label(self.mf, text=str(self.task_name), width=60, justify='left', anchor='w')
        tmp.grid(column=0, row=0, sticky='nsew', padx=4)
        self.total_points = tk.StringVar()
        self.total_points.set("0")
        lb_total_points = tk.Entry(self.mf,width=4,textvariable=self.total_points,justify='right',disabledbackground='white',background='white',foreground='DeepPink3', disabledforeground='DeepPink3')
        lb_total_points.grid(column=2,row=0, sticky='nsew')

        self.total_points.trace('w', self.points_validation)

        self.lb_tp = tk.Label(self.mf, text="/" + str(self.task_points))
        self.lb_tp.grid(column=3,row=0, sticky='nsew',padx=4)

        if subtasks == None or len(subtasks) == 1:
            self.correction_tsc = TextScrollCombo(self.mf, height=100)
            self.correction_tsc.grid(row=1, column=0, columnspan=4, padx=2, pady=7, sticky='nsew')
            pass
        else:
            self.correction_tsc = TextScrollCombo(self.mf, height=35)
            self.correction_tsc.grid(row=1, column=0, columnspan=4, padx=2, pady=7, sticky='nsew')
            sub_task_letter = 'a'
            for i, subtask in enumerate(subtasks):
                if type(subtask) is dict:
                    pts = [*subtask][0]
                    self.subtasks.append(SubTaskBlock(self.mf, self.total_points, 2*i+3, sub_task_letter + ") " + subtask[pts], pts))
                    sub_task_letter = chr(ord(sub_task_letter) + 1)
                else:
                    self.subtasks.append(SubTaskBlock(self.mf, self.total_points, 2*i+3, sub_task_letter + ") Teilaufgabe " + str(i+1), subtask))
                    sub_task_letter = chr(ord(sub_task_letter) + 1)
                pass

            lb_total_points.config(state=tk.DISABLED)

    def points_validation(self, a, b, c):
        try: 
            val = float(self.total_points.get())
            if val > self.task_points:
                print("Für", "Aufgabe " + str(self.task_number), "wurden zu viele Punkte angerechnet. Setze auf Maximum.")
                self.total_points.set(self.task_points)
            elif val < 0:
                print("Für", "die Aufgabe", str(self.task_number), "wurden negative Punkte angerechnet. Setze auf 0.")
                self.total_points.set("0")

        except ValueError as err:
            print(err)

    def grid(self, **options):
        self.mf.grid(sticky='nsew')
        self.mf.grid(options)

class EcorrectGui():
    """
        Graphical User Interface for Ecorrect
    """
    def __init__(self, m = None, v = None):
        """ show the main Window """
        self.mw = tk.Tk()
        self.mw.resizable(height=True, width=True)
        self.mw.title("ecorrect - GUI")
        # self.mw.geometry("600x400")
        self._place_toolbar()
        self._assign_handlers()
        self._load_status_text()
        self._create_notebook()
        self._t1_setup_correction()
        self._t2_setupgroups()

    def _place_toolbar(self):
        self.menu = tk.Menu(self.mw, tearoff=0)
        # Assign the Menu
        self.mw.config(menu=self.menu)
        # Load File Menu
        file_menu = tk.Menu(self.mw, tearoff=0)
        self.menu.add_cascade(label='Laden', menu=file_menu)
        file_menu.add_command(label='Abgabe',command=self.e_load_file)
        file_menu.add_command(label='Konfiguration',command=self.e_load_config)
        # Start-Action
        self.menu.add_command(label='Start', command=self.e_start_working, state=tk.DISABLED)
        # config_menu = tk.Menu(self.mw, tearoff=0)
        # menu.add_cascade(label='Konfiguration', menu=config_menu)
        # config_menu.add_command(label='Laden',command=self.e_load_config)
        # Help Menu
        self.help_menu = tk.Menu(self.mw, tearoff=0)
        self.menu.add_cascade(label='Allgemeines', menu=self.help_menu)
        self.help_menu.add_command(label='Update List', command=self.populate_t1_tv, state=tk.DISABLED)
        self.help_menu.add_command(label='About', state=tk.DISABLED)
        # Close-Action
        # self.menu.add_command(label='Schließen', command=self.quit)

    def _load_status_text(self):
        self.status_text = tk.Text(self.mw, wrap='word', height = 2, state='disabled', relief='flat')
        self.status_text.pack(fill='x',side='bottom')# place(x=1, rely=1.0, relwidth=1.0, anchor='sw')
        # self.status_text.pack(expand = YES)
        sys.stdout = StdoutRedirector(self.status_text,sys.stdout)
        sys.stderr = StdoutRedirector(self.status_text,sys.stderr)

    def _t2_setupgroups(self):
        for x in range (2):
            tk.Grid.columnconfigure(self.t2_config, x, weight=1)
        tk.Grid.rowconfigure(self.t2_config, 0, weight=1)
        self.t2_tv = ttk.Treeview(self.t2_config)
        self.t2_tv.column("#0", width=180, minwidth=180, stretch=tk.YES)
        self.t2_tv.heading("#0",text="Abgabepartner",anchor=tk.W)
        self.t2_tv.grid(column=0,sticky='nsew',row=0)
        # self.t2_tv.pack(fill='y',side='left',expand=True)
        # Other configurations
        # we will redo this as a treeview :D
        self.t2_settings_tv = ttk.Treeview(self.t2_config)
        self.t2_settings_tv["columns"] = ("wert")#,"beschreibung")
        self.t2_settings_tv.column("#0", width=220, minwidth=20, stretch=tk.NO)
        self.t2_settings_tv.column("wert", width=260, minwidth=20, stretch=tk.YES)
        # self.t2_settings_tv.column("beschreibung", width=200, minwidth=20, stretch=True)
        self.t2_settings_tv.heading("#0",text="Bezeichner",anchor=tk.W)
        self.t2_settings_tv.heading("wert",text="Wert",anchor=tk.W)
        # self.t2_settings_tv.heading("beschreibung",text="Beschreibung",anchor=tk.W)
        self.t2_settings_tv.grid(column=1,sticky='nsew',row=0)

        # # TODO: Specify MAXWIDTH
        # self.corrector = tk.StringVar()
        # # self.t2_corrector_label = tk.Label(self.t2_config, textvariable=self.corrector, relief='flat', justify='left')# , width=120)
        # # # self.t2_corrector_label.pack(side='top', fill='x', expand=True)
        # # self.t2_corrector_label.grid(row=0, column=1,sticky='w', padx=15)
        # # # self.t2_target_zip_label.pack(side='top', fill='x', expand=True)
        # self.target_zip = tk.StringVar()
        # # self.t2_target_zip_label = tk.Label(self.t2_config, textvariable=self.target_zip, relief='flat', justify='left')# , width=120)
        # # self.t2_target_zip_label.grid(row=1, column=1,sticky='w', padx=15)

        # self.working_dir = tk.StringVar()
        # # self.t2_working_dir_label = tk.Label(self.t2_config, textvariable=self.working_dir, relief='flat', justify='left')# , width=120)
        # # self.t2_working_dir_label.grid(row=2, column=1,sticky='w', padx=15)

        # self.correction_dir = tk.StringVar()
        # # self.t2_correction_dir_label = tk.Label(self.t2_config, textvariable=self.correction_dir, relief='flat', justify='left')# , width=120)
        # # self.t2_correction_dir_label.grid(row=3, column=1,sticky='w', padx=15)
        self.e_load_ec_config()

        # TOTO: append all Settings


    def _t1_setup_correction(self):
        tk.Grid.columnconfigure(self.t1_sheets, 1, weight=1)
        for y in range (3):
            tk.Grid.rowconfigure(self.t1_sheets, y+1, weight=1)
        self.t1_tv = ttk.Treeview(self.t1_sheets, height=19)
        self.t1_tv["columns"] = ("metadata")
        self.t1_tv.column("#0", width=220, minwidth=180, stretch=tk.NO)
        self.t1_tv.column("metadata", width=70, minwidth=70, stretch=tk.YES)
        self.t1_tv.heading("#0",text="Abgabepartner",anchor=tk.W)
        self.t1_tv.heading("metadata", text="Metadaten",anchor=tk.W)
        self.t1_tv.grid(column=0,rowspan=5,sticky='nsew')
        # TODO: style is somewhat wip ^^
        self.t1_tv.tag_configure('odd', background='#E8E8E8')
        self.t1_tv.tag_configure('even', background='#DFDFDF')
        self.t1_tv.bind('<<TreeviewSelect>>', self.t1_tv_on_click)

        # Metadata part :D
        lf_metadata = tk.LabelFrame(self.t1_sheets, text = "Metadaten")
        lf_metadata.grid(column=1, row=0, sticky='nsew', padx=10,pady=2)

        self.t1_s_name = tk.Label(lf_metadata, text="Name: ", width=60, justify='left', anchor='w')
        self.t1_s_name.grid(column=0, row=0, sticky='nsew', padx=10)
        self.t1_s_team = tk.Label(lf_metadata, text="Mitglieder: ", width=60,justify='left', anchor='w')
        self.t1_s_team.grid(column=0, row=1, sticky='nsew', padx=10)

        self.t1_s_f = tk.Frame(self.t1_sheets)
        self.t1_s_f.grid(column=1,row=1,rowspan=3,sticky='nsew',padx=10,pady=10) 
        tk.Grid.columnconfigure(self.t1_s_f, 0, weight=1)
        tk.Grid.rowconfigure(self.t1_s_f, 0, weight=1)
        self.t1_s_mf = ScrolledWindow(self.t1_s_f, height=400)
        self.t1_s_mf.grid(column=0,row=0,sticky='nsew',padx=10,pady=10) 

        self.fnt = tkf.Font(size=12)

        tmp_lf = tk.LabelFrame(self.t1_s_mf.scrollwindow, text = "Intro-Text")
        tmp_lf.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)

        self.t1_intro_box = TextScrollCombo(tmp_lf, height=80)
        self.t1_intro_box.txt.config(relief='flat', undo=True, wrap='word', borderwidth=0, font=self.fnt)
        self.t1_intro_box.pack(fill='both', expand=True, padx=2,pady=2)

        self.r_curgroup = '' # empty it

        # tk.Grid.columnconfigure(self.t1_s_mf,0,weight=1)

        # vbar = tk.Scrollbar(self.t1_s_mf, orient='vertical')
        # vbar.pack(side='right', fill='y')

        # self.t1_s_mc = tk.Canvas(self.t1_s_mf, width=300, height=300, scrollregion=(0,0,300,500), yscrollcommand=vbar.set)
        # vbar.config(command=self.t1_s_mc.yview)

        # self.t1_s_mc.pack(side='left', expand=True, fill='both')

        # for i in range(65):
        #     tmp = tk.Label(self.t1_s_mc, text="Wufudufu: " + str(i),height=1)
        #     tmp.pack(fill='y', expand=True)

        # self.t1_s_mc.config(scrollregion=self.t1_s_mc.bbox('all'))

        # Lower start buttn, siabled first
        self.t1_bt_frame = tk.Frame(self.t1_sheets)
        self.t1_bt_frame.grid(column=1, row=4, sticky='nsew', padx=10, pady=10)

        self.t1_bt_correct = tk.Button(self.t1_bt_frame, text="Starte Korrektur", state=tk.DISABLED, command=self.t1_start_correction)
        self.t1_bt_correct.pack(expand=True, fill='both', side='left',padx=2)
        self.t1_bt_save = tk.Button(self.t1_bt_frame, text="Speichere Korrektur", state=tk.DISABLED, command=self.t1_save_correction)
        self.t1_bt_save.pack(expand=True, fill='both', side='left',padx=2)


    def _create_notebook(self):
        self.notebook = ttk.Notebook(self.mw)
        self.t1_sheets = tk.Frame(self.notebook)
        self.t2_config = tk.Frame(self.notebook)
        self.notebook.add(self.t1_sheets, text = "Abgaben")
        self.notebook.add(self.t2_config, text = "Konfiguration")
        self.notebook.pack(fill='both',side='top',expand=True)# place(x=1, rely=0, relwidth=1.0, anchor='nw', relheight=0.9)

    def _assign_handlers(self):
        self.mw.protocol("WM_DELETE_WINDOW", self.quit)

    def show(self):
        self.mw.mainloop()

    def quit(self):
        if tkmb.askyesno("Programm schließen?", "Soll das Programm wirklich geschlossen werden?"):
            self.mw.destroy()

    def t1_tv_on_click(self, event=None):
        sel_index = self.t1_tv.selection()[0]
        while self.t1_tv.parent(sel_index) != '':
            sel_index = self.t1_tv.parent(sel_index)
        if self.t1_tv.item(sel_index)['text'] == self.r_curgroup:
            return # bereits ausgewählt
        # This should only retrigger if it is a root-element
        # print("Selected: " + sel_index + " (" + self.t1_tv.item(sel_index)['text'] + ")")
        # TODO: use item selection to allow preload of files, than add correction button
        #       on press, files shall be opened, below there shall be a Text-Box (maybe /w Field generation to enter the Data?)
        self.t1_s_name.config(text="Name: " + self.t1_tv.item(sel_index)['text'])
        self.t1_s_team.config(text="Mitglieder: " + ecorrect.decode_by_groupname(self.t1_tv.item(sel_index)['text']))
        self.r_curgroup = self.t1_tv.item(sel_index)['text']

        if self.r_curgroup == '':
            self.t1_bt_correct.config(state=tk.DISABLED)
            self.t1_bt_save.config(state=tk.DISABLED)
            # self.t1_s_f.config(state=tk.DISABLED)
        else:
            self.t1_bt_correct.config(state=tk.NORMAL)
            self.t1_bt_save.config(state=tk.NORMAL)
            # self.t1_s_f.config(state=tk.NORMAL)

        # Isolated Group-Identifier
        grp = getGroupTag(self.r_curgroup)
        # Search if there is already a correction
        tfile = os.path.join(ecorrect.ec_config['correction_dir'], self.r_curgroup, grp)
        
        
        self.populate_tasks()


        def free_text(r):
            """ remove trailing and ending newlines """
            return ("\n".join([_r.strip() for _r in r])).strip("\n")
        

        if os.path.isfile(tfile):
            # Korrektur gefunden
            
            # Wir laden die Daten - machen wir das zur Einfachheit mal direkt hier drin
            # Zuerst verwerfen wir alles, bis die init-line
            with open(tfile, 'r') as f:
                lines = f.readlines()
                b_init_seen = False
                b_mode_intro = False
                b_mode_task_intro = False
                b_mode_subtask_intro = False
                i_task_counter = -1 # init offset
                i_subtask_counter = -1 # init offset
                cache = []
                # TODO: mark on change indention
                for i, l in enumerate(lines):                            
                    # print(i,":",l,end='') # nl done by 
                    if not b_init_seen and re.match(r_init_line, l, re.I | re.M):
                        b_init_seen = True
                        b_mode_intro = True
                    else: 
                        m_t = re.match(r_task_start, l, re.I | re.M)
                        m_s = re.match(r_subtask_start, l, re.I | re.M)

                        if m_t: # task
                            i_task_counter += 1
                            if b_mode_intro: # stash old intro-line
                                self.t1_intro_box.txt.delete('1.0', 'end')
                                self.t1_intro_box.txt.insert('1.0', free_text(cache))
                                cache = []
                                b_mode_intro = False
                            if b_mode_task_intro: # stash task lines
                                # as we have to access the last block, we will decrement
                                self.t1_taskblocks[i_task_counter-1].correction_tsc.txt.delete('1.0', 'end')
                                self.t1_taskblocks[i_task_counter-1].correction_tsc.txt.insert('1.0', free_text(cache))
                                cache = []
                                b_mode_task_intro = False # just to be consistent :D
                            if b_mode_subtask_intro: # stash subtask lines
                                self.t1_taskblocks[i_task_counter-1].subtasks[i_subtask_counter].correction_tsc.txt.delete('1.0', 'end')
                                self.t1_taskblocks[i_task_counter-1].subtasks[i_subtask_counter].correction_tsc.txt.insert('1.0', free_text(cache))
                                cache = []
                                b_mode_subtask_intro = False

                            # print("Is Task-Line")
                            pts = m_t.group("got_pts")
                            self.t1_taskblocks[i_task_counter].total_points.set(pts)

                            b_mode_task_intro = True # Collect intro for Task, this is, if there is no subtasks, the collection of the main block
                            i_subtask_counter = -1 # reset

                        elif m_s: # subtask
                            i_subtask_counter += 1
                            # print("Is Subtask-Line")

                            if b_mode_task_intro: # stash task lines
                                # as we have to access the last block, we will decrement
                                self.t1_taskblocks[i_task_counter].correction_tsc.txt.delete('1.0', 'end')
                                self.t1_taskblocks[i_task_counter].correction_tsc.txt.insert('1.0', free_text(cache))
                                cache = []
                                b_mode_task_intro = False # just to be consistent :D
                            elif b_mode_subtask_intro: # stash subtask lines
                                self.t1_taskblocks[i_task_counter].subtasks[i_subtask_counter-1].correction_tsc.txt.delete('1.0', 'end')
                                self.t1_taskblocks[i_task_counter].subtasks[i_subtask_counter-1].correction_tsc.txt.insert('1.0', free_text(cache))
                                cache = []
                                b_mode_subtask_intro = False

                            pts = m_s.group("got_pts")
                            self.t1_taskblocks[i_task_counter].subtasks[i_subtask_counter].Xset(pts)

                            b_mode_subtask_intro = True

                        else: 
                            # Use last mode to enter the data :D
                            if b_mode_intro or b_mode_task_intro or b_mode_subtask_intro:
                                cache.append(l)
                            pass

                # cleanse indention mismatch to purge author
                dcache = []
                for dc in cache:
                    if len(dc) - len(dc.lstrip()) > 0:
                        dcache.append(dc)

                if b_mode_intro: # stash old intro-line
                    self.t1_intro_box.txt.delete('1.0', 'end')
                    self.t1_intro_box.txt.insert('1.0', free_text(dcache))
                    dcache = []
                    b_mode_intro = False
                if b_mode_task_intro: # stash task lines
                    # as we have to access the last block, we will decrement
                    self.t1_taskblocks[i_task_counter].correction_tsc.txt.delete('1.0', 'end')
                    self.t1_taskblocks[i_task_counter].correction_tsc.txt.insert('1.0', free_text(dcache))
                    dcache = []
                    b_mode_task_intro = False # just to be consistent :D
                if b_mode_subtask_intro: # stash subtask lines
                    self.t1_taskblocks[i_task_counter].subtasks[i_subtask_counter].correction_tsc.txt.delete('1.0', 'end')
                    self.t1_taskblocks[i_task_counter].subtasks[i_subtask_counter].correction_tsc.txt.insert('1.0', free_text(dcache))
                    dcache = []
                    b_mode_subtask_intro = False
            pass

    def e_load_config(self):
        """ Goal is to get the Name of the target Configuration-File """
        filename = tkfd.askopenfilename(title="Wähle die Konfigurationsdatei aus...", filetypes=((".yml Dateien", ".yaml .yml"),("Alle Dateien", ".")))

        # we will use the default config-loading hook of ecorrect
        if filename != "":
            print ("Loading Config-File: " + filename)
            ecorrect.parse_yaml(filename)
            self.e_load_ec_config()
        return filename

    def e_load_ec_config(self):
        # here we can pack the list, ec_config["partners"]
        # assign settings - wuup wuup.
        self.t2_tv.delete(*self.t2_tv.get_children())# cleanup
        for group in ecorrect.ec_config["partners"]:
            t2_croot = self.t2_tv.insert("", 'end', text=group['name'])# + "(" + helper_concat_members(group['members']) + ")")
            member_counter = 0
            for member in group['members']:
                member_counter += 1
                self.t2_tv.insert(t2_croot, 'end', text=str(member_counter) + ". " + member)
        self.t2_settings_tv.delete(*self.t2_settings_tv.get_children())
        def populate(root, setting, elem):
            if type(elem) is dict:
                t_root = self.t2_settings_tv.insert(root, 'end', text=str(setting) , values=("<Dict>",""))
                for key in elem:
                    populate(t_root, key, elem[key])
            elif type(elem) is list:
                t_root = self.t2_settings_tv.insert(root, 'end', text=str(setting) , values=("<Liste>",""))
                for i, t_elem in enumerate(elem):
                    populate(t_root, str(i+1) + ".", t_elem)
                    # self.t2_settings_tv.insert(t_root, 'end', text=str(i+1) + ". ", values=(str(t_elem)))
            elif type(elem) is tuple:
                t_root = self.t2_settings_tv.insert(root, 'end', text=str(setting) , values=("<Tuple>",""))
                for i, t_elem in enumerate(elem):
                    populate(t_root, str(i+1) + ".", t_elem)
                    # self.t2_settings_tv.insert(t_root, 'end', text=str(i+1) + ". ", values=(str(t_elem)))
            else:
                self.t2_settings_tv.insert(root, 'end', text=str(setting) , values=("'" + str(elem) + "'", ""))
        for setting in ecorrect.ec_config:
            if 'partners' not in setting:
                entry = ecorrect.ec_config[str(setting)]
                populate('', setting, entry)        
        # self.corrector.set("corrector: '" + ecorrect.ec_config["corrector"] + "'")
        # self.target_zip.set("target_zip: '" + ecorrect.ec_config["target_zip"] + "'")
        # self.working_dir.set("working_dir: '" + ecorrect.ec_config["working_dir"] + "'")
        # self.correction_dir.set("correction_dir: '" + ecorrect.ec_config["correction_dir"] + "'")

        self.t1_taskblocks = []
        self.populate_tasks()

    def populate_tasks(self):
        # Parse Tasks
        for tb in self.t1_taskblocks:
            tb.mf.destroy()
        self.t1_taskblocks = []
        for i, task in enumerate(ecorrect.ec_config['sheet_data']):
            self.t1_taskblocks.append(TaskBlock(self.t1_s_mf.scrollwindow, i+1, task['name'], task['total'], task['tasks']))
            self.t1_taskblocks[-1].grid(row=i+1,column=0,padx=4,pady=2)

    def e_load_file(self):
        """ Goal is to get the Name of the target Zip-File """
        filename = tkfd.askopenfilename(title="Wähle das (Moodle-)Archiv aus...", filetypes=((".zip Dateien", ".zip"),("Alle Dateien", ".")))
        if filename != "":
            print ("Loading (zip): " + filename)
            ecorrect.ec_config["target_zip"] = filename
            if os.path.isfile(filename):
                self.menu.entryconfigure(1, state=tk.NORMAL)
            else: 
                self.menu.entryconfigure(1, state=tk.DISABLED)

            self.e_load_ec_config()
        return filename

    def t1_start_correction(self):
        print("Started Correction")
    # 
    # ╔╦╗┌─┐┬┌┐┌  ╔═╗─┐ ┬┌┬┐┌─┐┌─┐┌┬┐┬┌─┐┌┐┌
    # ║║║├─┤││││  ║╣ ┌┴┬┘ │ ├─┤│   │ ││ ││││
    # ╩ ╩┴ ┴┴┘└┘  ╚═╝┴ └─ ┴ ┴ ┴└─┘ ┴ ┴└─┘┘└┘
    # 
    def e_start_working(self):
        do_extraction = True
        # filter_start = ""
        if os.path.isdir(ecorrect.ec_config["correction_dir"]):
            if tkmb.askyesno("Korrektur Fortsetzen?", "Information, der Ordner: '" + ecorrect.ec_config["correction_dir"]+ '" existiert bereits! Bestehende Korrektur fortsetzen?'):
                # filter_start = input("Bitte gib den (Gruppen-)Namen ein, bei du die Korrektur fortführen möchtest> ")
                print("Führe Korrektur fort...")
                do_extraction = False

        if do_extraction:
            # delete working dir:
            if os.path.isdir(ecorrect.ec_config["working_dir"]):
                shutil.rmtree(ecorrect.ec_config["working_dir"])
            if ecorrect.ec_config["clean_dirs"]:
                if os.path.isdir(ecorrect.ec_config["correction_dir"]):
                    shutil.rmtree(ecorrect.ec_config["correction_dir"])
            else:
                print("Dir-Clean disabled!")

        # print(ecorrect.ec_config)
        # print(ecorrect.ec_config["target_zip"] + " - " + ecorrect.ec_config["working_dir"])
        # Zip file to unpack is stored in 'target_zip'
        ecorrect.extract_zip(ecorrect.ec_config["target_zip"], ecorrect.ec_config["working_dir"])

        # Iterate over all file
        for filename in os.listdir(ecorrect.ec_config["working_dir"]):
                fmatch = ecorrect.check_match(ecorrect.ec_config["name_patterns"], filename)
                if fmatch != None:
                    # print(fmatch.groupdict())
                    fdict = fmatch.groupdict()
                    # extract to group target
                    group = ecorrect.get_partner(fdict["FirstName"],fdict["LastName"])
                    group_tardir = None
                    if(group == None):
                        # print("\033[32mFor: '" + fdict["FirstName"] + " " + fdict["LastName"] + "' no group was found!\033[0m")
                        group_tardir = os.path.join(ecorrect.ec_config["correction_dir"],fdict["FirstName"] + " " + fdict["LastName"])
                    else:
                        # print("\033[32mFor: '" + fdict["FirstName"] + " " + fdict["LastName"] + "' the group: " + group["name"] + " has been identified!\033[0m")
                        group_tardir = os.path.join(ecorrect.ec_config["correction_dir"],"Group: " + group["name"])

                    if os.path.isdir(group_tardir):
                        # print("The targetfile does exist. Adding the file")
                        pass
                    else:
                        # print("The targetfile doesn't exist. Creating...")
                        os.makedirs(group_tardir)

                    filename_fullpath = os.path.join(ecorrect.ec_config["working_dir"],filename)
                    if(fdict["FileExtension"] == "zip"):
                        ecorrect.extract_zip(filename_fullpath,group_tardir)
                    else:
                        shutil.copyfile(filename_fullpath,os.path.join(group_tardir,fdict["FileName"] + "." + fdict["FileExtension"]))
                else:
                    print("The File '" + filename + "' does not satisfy any pattern in 'name_patterns'!")
        # No add all files to the TV, maybe 
        self.populate_t1_tv()
        self.help_menu.entryconfigure(0, state=tk.NORMAL)

    def populate_t1_tv(self):
        self.t1_tv.delete(*self.t1_tv.get_children())
        even_odd = False
        for dirname in sorted(os.listdir(ecorrect.ec_config["correction_dir"])):
            group_name = dirname
            current_groupnode = self.t1_tv.insert("", 'end', text=group_name, values=("<WIP>",""), tags=(('even' if even_odd else 'odd',"")))
            # print(os.path.join(ecorrect.ec_config["correction_dir"],dirname))
            for root, dirs, files in os.walk(os.path.join(ecorrect.ec_config["correction_dir"],dirname)):
                # path = root.split(os.sep)
                if group_name == os.path.basename(root):
                    current_subnode = current_groupnode
                else:
                    current_subnode = self.t1_tv.insert(current_groupnode, 'end', text=os.path.basename(root), values=("",""))
                # print((len(path) - 1) * '---', os.path.basename(root))
                for file in files:
                    self.t1_tv.insert(current_subnode, 'end', text=file, values=("",""))
                    # print(len(path) * '---', file)
            even_odd = not even_odd
            # print("Adding: " + group_name + " (" + ('even' if even_odd else 'odd') + ")")

    # 
    # ╔═╗┌┬┐┌─┐┬─┐┌─┐┌─┐┌─┐
    # ╚═╗ │ │ │├┬┘├─┤│ ┬├┤
    # ╚═╝ ┴ └─┘┴└─┴ ┴└─┘└─┘
    # 
    def t1_save_correction(self):
        print("Generiere Speicherdaten...")
        group_name = ecorrect.decode_by_groupname(self.r_curgroup)
        tar_grouppath = os.path.join(ecorrect.ec_config["correction_dir"],self.r_curgroup)

        correction_file = os.path.join(tar_grouppath, getGroupTag(self.r_curgroup)) # replace is sloppy

        # Calculate Total Points:
        total_sum = 0
        max_sum = 0
        for tb in self.t1_taskblocks:
            total_sum += getNum(tb.total_points.get())
            max_sum += getNum(tb.task_points)
        # print(total_sum,"/",max_sum)
        def print_if_ne(c, a):
            if a != "":
                c.write(a + "\n")

        with open(correction_file,'w') as correction:
            print_if_ne(correction, ecorrect.ec_config["correction_template"]["pre"])
            correction.write("Korrektur für: " + group_name + "\n\n")
            correction.write("> Gesamtpunktzahl: " + str(total_sum) + "/" + str(max_sum) + " " + ("(bestanden)" if total_sum/max_sum >= ecorrect.ec_config['min_percentage'] else "(nicht bestanden)") + "\n\n")
            print_if_ne(correction, self.t1_intro_box.txt.get(1.0, 'end'))
            print_if_ne(correction, ecorrect.ec_config["correction_template"]["in"])
            for block in self.t1_taskblocks:#  ecorrect.ec_config["sheet_data"]:
                correction.write(block.task_name.ljust(int(ecorrect.ec_config["padding"]-6)) + str(getNum(block.total_points.get())).rjust(4) + "/" + str(block.task_points) + " " + ("Punkt" if block.task_points ==1 else "Punkte") + "\n")
                sub_task_letter = 'a'
                # main text here
                for line in block.correction_tsc.txt.get(1.0,'end').split('\n'):
                    correction.write("   " + line + "\n") # add padding
                if(len(block.subtasks)>1):
                    for task in block.subtasks:
                        correction.write(" - " + task.sub_task_name.ljust(int(ecorrect.ec_config["padding"])-13) + str(" (" + str(getNum(task.points.get()))).rjust(8) + "/" + str(getNum(task.sub_task_points)) + ")\n")
                        sub_task_letter = chr(ord(sub_task_letter) + 1)
                        print_if_ne(correction, ecorrect.ec_config["correction_template"]["mid-sub"])
                        for line in task.correction_tsc.txt.get(1.0,'end').split('\n'):
                            correction.write("     " + line + "\n") # add padding
                print_if_ne(correction, ecorrect.ec_config["correction_template"]["mid"])
            print_if_ne(correction, ecorrect.ec_config["correction_template"]["out"])
            correction.write(ecorrect.ec_config["corrector"]+"\n")
            print_if_ne(correction, ecorrect.ec_config["correction_template"]["post"])
            
def helper_concat_members(mls):
    if(len(mls) == 2):
        return mls[0] + " und " + mls[1]
    else:
        return ", ".join(mls)
#
#
#
# .##.....##....###....####.##....##....########.....###....########..########
# .###...###...##.##....##..###...##....##.....##...##.##...##.....##....##...
# .####.####..##...##...##..####..##....##.....##..##...##..##.....##....##...
# .##.###.##.##.....##..##..##.##.##....########..##.....##.########.....##...
# .##.....##.#########..##..##..####....##........#########.##...##......##...
# .##.....##.##.....##..##..##...###....##........##.....##.##....##.....##...
# .##.....##.##.....##.####.##....##....##........##.....##.##.....##....##...
#
#
#

if __name__ == "__main__":
    gui = EcorrectGui()
    gui.show()